# THIS PACKAGE IS DEPRECATED

Do not use this package, as it will not receive any updates and may be deleted in the future.

# FSi Metadata Component Documentation

FSi Metadata Component is a library that provide some commonly used mechanisms to 
read configurations for classes from different sources like annotations, yaml or xml.
At the moment only php files annotations are supported.

## Setup and autoloading ##

We highly recommend to use autoloader generated by composer.phar

**Adding reflection into composer.json**

    {
        ... 
        "require": {
            ... 
            "fsi/metadata": "0.9.*" 
            ...
        },
        ...
    }

## Usage ##

FSi Metadata Component provides ClassMetadata object that can be easly overwritten. Default ClassMetadata object allows 
you to strore inside of it configuration for class, properties and methods. 
This can be done by using methods "addClassMetadata", "addPropertyMetadata", "addMethodMetadata". 

What you need to do is to create class that extends from one of abstract drivers like AbstractAnnotationDriver. 

Example of reading annotations from php class files. 


**Annotation driver** 

```php
namespace FSi\Bundle\SiteBundle\Metadata\Driver;

use FSi\Component\Metadata\ClassMetadataInterface;
use FSi\Component\Metadata\Driver\AbstractAnnotationDriver;

class AnnotationDriver extends AbstractAnnotationDriver
{
    public function loadClassMetadata(ClassMetadataInterface $metadata)
    {
        $classReflection  = $metadata->getClassReflection();
        $className        = $classReflection->getName();

        $classReflectionProperties = $classReflection->getProperties();
        foreach ($classReflectionProperties as $property) {
            if ($property->getDeclaringClass()->getName() == $className) {
                foreach ($this->getAnnotationReader()->getPropertyAnnotations($property) as $element) {
                    $metadata->addPropertyMetadata($property->name, $element->name, $element->value);
                }
            }
        }
    }
}
```
    
**Annotation declaration**

```php
namespace FSi\Bundle\SiteBundle\Metadata\Mapping\Annotation;

use Doctrine\Common\Annotations\Annotation;

/** @Annotation */
final class Field extends Annotation {
    public $name;
    public $value;
}
```

**Example action in symfony 2 controller**

```php
    public function metadataAction()
    {
        $driver = new \FSi\Bundle\SiteBundle\Metadata\Driver\AnnotationDriver($this->get('annotation_reader'));
        
        $factory = new MetadataFactory($driver);
        
        $metdata = $factory->getClassMetadata('FSi\Bundle\SiteBundle\Entity\MetaTest');
    }
```

**Example action in symfony 2 controller (with cache)**

All you need to do to implement caching metadata is create the cache object from ``Doctrine\Common\Cache`` and pass it
into ``MetadataFactory`` constructor. For development purposes we suggest to use ``ArrayCache`` instead of not using any cache.

```php
public function metadataAction()
{
    $cache = new Doctrine\Common\Cache\ApcCache(); 
    
    $driver = new \FSi\Bundle\SiteBundle\Metadata\Driver\AnnotationDriver($this->get('annotation_reader'));
    
    // the third parameter should be used when one cache instance will be used in many metadata factories. 
    $factory = new MetadataFactory($driver, $cache, 'cache-prefix');
    
    $metdata = $factory->getClassMetadata('FSi\Bundle\SiteBundle\Entity\MetaTest');
}
```

Sometimes default ``ClassMetadata`` is not enough. You can create own class that implements 
``ClassMetadataInterface`` and pass class name into ``MetadataFactory`` constructor as third parameter. 

**Factory constructor example with custom metadata class**

```php
$factory = new MetadataFactory($driver, $cache, 'cache-namespace', 'FSi\SiteBundle\Metadata\MyClassMetadata');
```

If you want to use Metadata Component in two separate mechanisms, inside of the 
same application you should create new ``MetatadaFactory`` and appropriate driver in each 
mechanism but cache driver may be the same object each time. It is possible when 
cache mechanism is used with different prefix and/or metadata class for each factory object.
